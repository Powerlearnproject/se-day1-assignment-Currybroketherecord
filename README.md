[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18390490&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software systems
Software engineering follows structured methodologies, such as Agile, DevOps, or Waterfall, to ensure that software products meet user requirements, perform efficiently, and are maintainable over time

Identify and describe at least three key milestones in the evolution of software engineering.

1. The 1968 NATO Software Engineering Conference
   It marked the recognition of software development as an engineering discipline, emphasizing structured methodologies, best practices, and systematic approaches.
2. The Advent of Structured Programming
   It improved code readability, maintainability, and reliability, reducing the likelihood of errors.
3. The Rise of Agile Methodologies
   Agile revolutionized software engineering by making development faster, more efficient, and user-focused.

List and briefly explain the phases of the Software Development Life Cycle.

1. Planning
This phase involves defining the project scope, objectives, and feasibility.
2. Requirement Analysis
Developers and business analysts gather and document functional and non-functional requirements.
3. Design
Software architecture and system design are created based on requirements.
4. Implementation (Coding)
Developers write code based on the design documents.
5. Testing
The software undergoes various testing types, including unit testing, integration testing, and system testing.
6. Deployment
The software is deployed to a live environment or released to users.
7. Maintenance & Support
After deployment, regular updates, bug fixes, and enhancements are made.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate. 

Waterfall Methodology is a linear, sequential approach where each phase of development is completed before moving to the next while Agile Methodology is an iterative, flexible approach where development occurs in small cycles (sprints), allowing for frequent feedback and changes.
Waterfall Methodology can be used for a bank system while agile methodology may be used for mobile apps

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

 Software Developer is responsible for designing, coding, and maintaining software applications.
 Quality Assurance Engineer ensures the software meets quality standards by testing for bugs, performance issues, and security vulnerabilities.
 Project Manager oversees the software development process, ensuring that the project stays on schedule, within budget, and meets stakeholder expectations.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Importance of IDEs
Increases Developer Productivity – Features like auto-completion, syntax highlighting, and debugging tools speed up coding.
Reduces Errors – Built-in error checking and debugging tools help identify and fix issues early.
Supports Multiple Languages & Frameworks – Many IDEs support various languages like Python, Java, JavaScript, and C++.
Simplifies Project Management – Includes tools for version control, code refactoring, and package management.
Examples :Visual Studio Code (VS Code), PyCharm
Importance of VCS
Facilitates Team Collaboration – Multiple developers can work on the same project without overwriting each other’s code.
Tracks Changes and Revisions – Developers can see the history of changes and revert to previous versions if needed.
Supports Branching and Merging – Developers can create feature branches, test new features, and merge them into the main codebase.
Prevents Data Loss – Code is backed up and stored securely in remote repositories (e.g., GitHub, GitLab, Bitbucket).
Examples :Git, Github, Gitlab

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

-Managing Complex Codebases
Challenge: As projects grow, maintaining, debugging, and understanding large codebases becomes difficult.
Strategy: Follow modular programming and clean code principles.
-Debugging and Fixing Bugs
Challenge: Identifying and fixing bugs can be time-consuming and frustrating.
Strategy: Use debugging tools available in IDEs 
- Keeping Up with Rapidly Changing Technologies
Challenge: New frameworks, programming languages, and tools emerge constantly, making it hard to stay updated.
Strategy: Follow industry trends through blogs, webinars, and conferences

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing is the smallest level of testing, where individual components or functions of the software are tested in isolation.
 Detects bugs early in development.
Integration Testing ensures that multiple components or modules work together as expected.
 Detects issues in data flow and communication between modules.
System Testing evaluates the complete software system against requirements to ensure end-to-end functionality.
  Verifies that the software meets business and technical requirements.
Acceptance Testing is the final phase of testing where the software is validated against business needs and user expectations. 
  Ensures the software meets real-world requirements before release.
  
#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the practice of designing and refining input prompts to guide AI models in generating more accurate, relevant, and useful responses. 
 1. Improves Response Quality
 2. Reduces Ambiguity & Misinterpretation
 3. Enhances AI Customization & Task Efficiency
 4.  Essential for AI-Assisted Automation & Business Use Cases
    
Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague prompt: Show me how to code using Java, I only know Python
Improved prompt: Explain to me using a code written in python how I can write the same code in Java which performs the same function
The improved prompt is clear that you understand coding and the only problem is you don't understand the syntax of Java and that's what you need help on
